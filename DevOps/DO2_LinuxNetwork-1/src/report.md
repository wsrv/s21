# Сети в Linux

Настройка сетей в Linux на виртуальных машинах.


## Contents

   1. [Инструмент ipcalc](#part-1-инструмент-ipcalc) 
   2. [Статическая маршрутизация между двумя машинами](#part-2-статическая-маршрутизация-между-двумя-машинами) 
   3. [Утилита iperf3](#part-3-утилита-iperf3) 
   4. [Сетевой экран](#part-4-сетевой-экран) 
   5. [Статическая маршрутизация сети](#part-5-статическая-маршрутизация-сети) 
   6. [Динамическая настройка IP с помощью DHCP](#part-6-динамическая-настройка-ip-с-помощью-dhcp) 
   7. [NAT](#part-7-nat) 
   8. [Допополнительно. Знакомство с SSH Tunnels](#part-8-дополнительно-знакомство-с-ssh-tunnels)

## Part 1. Инструмент **ipcalc**

##### 1) адрес сети *192.167.38.54/13*
* Скачаем утилиту `ipcalc` и используем команду `ipcalc 192.167.38.54/13`

<img src="src/screenshots/1.1.png" width="700">

##### 2) перевод маски *255.255.255.0* в префиксную и двоичную запись, */15* в обычную и двоичную, *11111111.11111111.11111111.11110000* в обычную и префиксную

* Cделаем перевод маски *255.255.255.0* в префиксную и двоичную запись с помощью команды `ipcalc 225.225.225.0`
     * Префиксная `24`
     * Двоичная `11111111.11111111.11111111. 00000000`

<img src="src/screenshots/1.2.png" width="700">

* */15* в обычную и двоичную, команда: `ipcalc /15`
     * Обычная `255.254.0.0`
     * Двоичная `11111111.11111110.00000000. 00000000`

<img src="src/screenshots/1.3.png" width="700">

* *11111111.11111111.11111111.11110000* (количество ненулевых бит 28) в обычную и префиксную с помощью команды `ipcalc 192.167.38.54/28` (так как нельзя указывать в качестве ввода двоичную форму адреса в ipcalc)
     * Обычная `255.255.255.240`
     * Префиксная `/28`

<img src="src/screenshots/1.4.png" width="700">

##### 3) минимальный и максимальный хост в сети *12.167.38.4* при масках: */8*, *11111111.11111111.00000000.00000000*, *255.255.254.0* и */4*
* используем команду `ipcalc 12.167.38.4/8` для маски `/8` 
    минимальный хост `12.0.0.1`
    максимальный хост `12.255.255.254`

<img src="src/screenshots/1.5.png" width="700">

*  так как `11111111.11111111.00000000.00000000` эквивалентно `16` используем команду `ipcalc 12.167.38.4/16` для маски `11111111.11111111.00000000.00000000` 
    минимальный хост `12.167.0.1`
    максимальный хост `12.167.255.254`

<img src="src/screenshots/1.6.png" width="700">

*  так как `255.255.254.0` эквивалентно `/23` используем команду `ipcalc 12.167.38.4/23` для маски `255.255.254.0` 
    минимальный хост `12.167.38.1`
    максимальный хост `12.167.39.254`

<img src="src/screenshots/1.7.png" width="700">

* Проверим можно ли обратиться к приложению, работающему на localhost, со следующими IP: 
* 194.34.23.100 (`нет`):

<img src="src/screenshots/1.8.png" width="700">

* 127.0.0.2 (`да`):

<img src="src/screenshots/1.9.png" width="700">

* 127.1.0.1 (`да`):

<img src="src/screenshots/1.10.png" width="700">

* 128.0.0.1 (`нет`):

<img src="src/screenshots/1.11.png" width="700">

##### Определить и записать в отчёт:
##### 1) какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных: *10.0.0.45*, *134.43.0.2*, *192.168.4.2*, *172.20.250.4*, *172.0.2.1*, *192.172.0.1*, *172.68.0.2*, *172.16.255.255*, *10.10.10.10*, *192.169.168.1*

Публичный IP адрес - называется IP адрес, который используется для выхода в Интернет. Частный IP адрес - адреса, используемые в локальных сетях (не может быть напрямую подключен к Интернету).

* К публичным относятся следующие IP адреса: `134.43.0.2`, `172.0.2.1`, `192.172.0.1`, `172.68.0.2`, `192.169.168.1`

<img src="src/screenshots/1.12.png" width="700">

* К частным относятся следующие IP адреса: `10.0.0.45`, `192.168.4.2`, `172.20.250.4`, `172.16.255.255`, `10.10.10.10`

<img src="src/screenshots/1.13.png" width="700">

##### 2) какие из перечисленных IP адресов шлюза возможны у сети *10.10.0.0/18*: *10.0.0.1*, *10.10.0.2*, *10.10.10.10*, *10.10.100.1*, *10.10.1.255*

* Из перечисленных IP адресов шлюзов у сети `10.10.0.0/18` возможны следующие: `10.10.0.2`, `10.10.10.10`, `10.10.1.255`. (так как они расположены в диапозоне между `min` и `max`)

<img src="src/screenshots/1.14.png" width="700">

## Part 2. Статическая маршрутизация между двумя машинами

* С помощью команды `ip a` посмотреть существующие сетевые интерфейсы на виртуальных машинах ws1 и ws2

<img src="src/screenshots/2.1.1.png" width="700">
<img src="src/screenshots/2.1.2.png" width="700">

* С помощью команды netstat `netstat -nr` проверяем адреса машин

<img src="src/screenshots/2.21.png" width="700">
<img src="src/screenshots/2.22.png" width="700">

* Для того чтобы задать следующие адреса и маски: ws1 - `192.168.100.10`, маска `/16`, ws2 - `172.24.116.8`, маска `/12` откроем и отредактируем согласно требованиям файл при помощи команды `sudo nano /etc/netplan/00-installer-config.yaml`

<img src="src/screenshots/2.31.png" width="700">
<img src="src/screenshots/2.32.png" width="700">

* Выполним команду `netplan apply` для перезапуска сервиса сети и проверим применились ли изменения 

<img src="src/screenshots/2.4.png" width="700">
<img src="src/screenshots/2.4.1.png" width="700">
<img src="src/screenshots/2.4.2.png" width="700">

* Добавим статический маршрут от одной машины до другой и обратно при помощи команды вида `ip r add`

<img src="src/screenshots/2.5.1.png" width="700">
<img src="src/screenshots/2.5.2.png" width="700">

* Пропингуем соединение между машинами с помощью команд `ping -c 2 172.24.116.8` и `ping -c 2 192.168.100.10`

<img src="src/screenshots/2.5.3.png" width="700">

* Перезапустим машины, данные не сохранились
* Добавляем статический маршрут от одной машины до другой, редактируя файл `etc/netplan/00-installer-config.yaml.` Команда: `sudo nano etc/netplan/00-installer-config.yaml`

<img src="src/screenshots/2.6.png" width="700">

* Применяем новые настройки с помощью команды `sudo netplan apply` и пропингуем соединение между машинами

<img src="src/screenshots/2.7.png" width="700">

## Part 3. Утилита **iperf3**
* 8Mbps = `1MB/s`, 100MB/s = `800000Kbps`, 1Gbps = `1000Mbps`

* Запускаем утилиту на ws1 в режиме сервер с флагом `-s` и запускаем на ws2 утилиту в режиме клиент с флагом `-c` и указываем IP-адрес ws1.

<img src="src/screenshots/3.1.png" width="700">

## Part 4. Сетевой экран

* Создадим файл */etc/firewall.sh*, имитирующий фаерволл, на ws1 и ws2 cо следующими правилами:
     * на ws1 применить стратегию когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило (это касается пунктов 4 и 5).
     * на ws2 применить стратегию когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5).
     * открыть на машинах доступ для порта 22 (ssh) и порта 80 (http).
     * запретить echo reply (машина не должна "пинговаться”, т.е. должна быть блокировка на OUTPUT).
     * разрешить echo reply (машина должна "пинговаться").

<img src="src/screenshots/4.1.png" width="700">

* Запустим файлы на обеих машинах командами `chmod +x /etc/firewall.sh` и `/etc/firewall.sh`

<img src="src/screenshots/4.2.png" width="700">

 Разница между стратегиями, применёнными в первом и втором файлах, заключается в следующем: в утилите iptables правила выполняются сверху вниз. На первой машине первым указано запрещающее правило на выход, поэтому она не сможет пропинговать другую машину. У второй машины, наоброт - первым указано разрешающее правило, значит она сможет пропинговать другую машину

#### 4.2. Утилита **nmap**
* Командой **ping** найдем машину, которая не "пингуется"

<img src="src/screenshots/4.3.png" width="700">

* Утилитой **nmap** покажем, что хост машины запущен

<img src="src/screenshots/4.5.png" width="700">

## Part 5. Статическая маршрутизация сети

Сеть: \
![part5_network](misc/images/part5_network.png)

#### 5.1. Настройка адресов машин
* Настроим конфигурации машин через редактирование `etc/netplan/00-installer-config.yaml` согласно сети на рисунке.

<img src="src/screenshots/5.1.png" width="700">

* Перезапустим сервис сети и командой `ip -4 a` проверим, что адрес машины задан верно.

 <img src="src/screenshots/5.1.1.png" width="700">
 <img src="src/screenshots/5.1.2.png" width="700">
 <img src="src/screenshots/5.1.3.png" width="700">
 <img src="src/screenshots/5.1.4.png" width="700">
 <img src="src/screenshots/5.1.5.png" width="700">

* Также пропингуем `ws22 с ws21` и `r1 с ws11`.

 <img src="src/screenshots/5.1.6.png" width="700">

#### 5.2. Включение переадресации IP-адресов.
* Для включения переадресации IP, выполним команду на роутерах:`sysctl -w net.ipv4.ip_forward=1`
*При таком подходе переадресация не будет работать после перезагрузки системы.*

 <img src="src/screenshots/5.2.png" width="700">

* Откроем файл */etc/sysctl.conf* и добавим в него следующую строку: `net.ipv4.ip_forward = 1`
*При использовании этого подхода, IP-переадресация включена на постоянной основе.*

 <img src="src/screenshots/5.3.png" width="700">

#### 5.3. Установка маршрута по-умолчанию

* Настраиваем маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавляем `gateway4`: ip роутера в файле конфигураций `etc/netplan/00-installer-config.yaml`

 <img src="src/screenshots/5.3.1.png" width="700">

* Вызовем `ip r` чтобы показать, что добавился маршрут в таблицу маршрутизации

 <img src="src/screenshots/5.3.2.png" width="700">
  <img src="src/screenshots/5.3.3.png" width="700">

* Пропингуем с `ws11` роутер `r2` и покажем на `r2`, что пинг доходит. Для этого используем команду: `tcpdump -tn -i eth1`

 <img src="src/screenshots/5.3.4.png" width="700">
 <img src="src/screenshots/5.3.5.png" width="700">

#### 5.4. Добавление статических маршрутов
* Добавим в роутеры r1 и r2 статические маршруты в файле конфигураций

<img src="src/screenshots/5.4.png" width="700">

* Вызвать `ip r` и показать таблицы с маршрутами на обоих роутерах. Пример таблицы на r1:

<img src="src/screenshots/5.4.1.png" width="700">

* Запустить команды `ip r list 10.10.0.0/[маска сети]` и `ip r list 0.0.0.0/0`на ws11:

<img src="src/screenshots/5.4.2.png" width="700">

Для адреса 10.10.0.0/18 был выбран маршрут, отличный от 0.0.0.0/0 (он попадает под маршрут по-умолчанию), т.к. машина ws11 соединена с сетью 10.10.0.0/18 по своему IP-адресу 10.10.0.2, для других адресов используется маршрут по умолчанию, который указан в файле 10.10.0.1.

#### 5.5. Построение списка маршрутизаторов

* Запустим на r1 команду дампа: `tcpdump -tnv -i enp0s8`

<img src="src/screenshots/5.5.png" width="700">

* При помощи утилиты `traceroute` построим список маршрутизаторов на пути от ws11 до ws21

<img src="src/screenshots/5.5.1.png" width="700">

#### 5.6. Использование протокола **ICMP** при маршрутизации
* Запустим на r1 перехват сетевого трафика, проходящего через eth0s8 с помощью команды: `tcpdump -n -i eth0s8 icmp`
* Пропингуем с ws11 несуществующий IP (например, *10.30.0.111*) с помощью команды:
`ping -c 1 10.30.0.111`

<img src="src/screenshots/5.5.3.png" width="700">



## Part 6. Динамическая настройка IP с помощью **DHCP**

##### Для r2 настроить в файле */etc/dhcp/dhcpd.conf* конфигурацию службы **DHCP**:

##### 1) указать адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети. 
* вносим изменения в файл `/etc/dhcp/dhcpd.conf`

<img src="src/screenshots/6.1.png" width="700">

##### 2) в файле *resolv.conf* прописать `nameserver 8.8.8.8.`
* вносим изменения в файл `/etc/resolv.conf`

<img src="src/screenshots/6.2.png" width="700">

* Перезагрузить службу **DHCP** командой `systemctl restart isc-dhcp-server`. 

<img src="src/screenshots/6.3.png" width="700">

* Машину ws21 перезагрузить при помощи `reboot` и через `ip a` показать, что она получила адрес. 
* Также пропинговать ws22 с ws21.

<img src="src/screenshots/6.4.png" width="700">

* Указать MAC адрес у ws11, для этого в *etc/netplan/00-installer-config.yaml* надо добавить строки: `macaddress: 10:10:10:10:10:BA`, `dhcp4: true`

<img src="src/screenshots/6.5.png" width="700">

##### Для r1 настроить аналогично r2, но сделать выдачу адресов с жесткой привязкой к MAC-адресу (ws11). Провести аналогичные тесты

- В отчёте этот пункт описать аналогично настройке для r2.

* вносим изменения в файл `/etc/dhcp/dhcpd.conf`

<img src="src/screenshots/6.1.1.png" width="700">

* вносим изменения в файл `/etc/resolv.conf`

<img src="src/screenshots/6.1.2.png" width="700">

* Перезагрузить службу **DHCP** командой `systemctl restart isc-dhcp-server`. 

<img src="src/screenshots/6.1.3.png" width="700">

* Машину ws11 перезагрузить при помощи `reboot` и через `ip a` показать, что она получила адрес. 

<img src="src/screenshots/6.1.4.png" width="700">

##### Запросить с ws21 обновление ip адреса
- В отчёте поместить скрины ip до и после обновления.

<img src="src/screenshots/6.22.png" width="700">

<img src="src/screenshots/6.23.png" width="700">

- `sudo dhclient -r eth0` - для обновления IP-адреса интерфейса с помощью команды dhclient можно использовать флаг -r, который предназначен для освобождения текущего IP-адреса и запуска процесса запроса нового адреса у DHCP-сервера. После этого можно запустить команду dhclient без каких-либо дополнительных флагов для получения нового IP-адреса от DHCP-сервера. Для отображения текущего IP-адреса интерфейса (например, eth0) при использовании команды sudo dhclient можно использовать флаг -4, который указывает на использование только протокола IPv4. Таким образом, полная команда будет выглядеть следующим образом: sudo dhclient -4 eth0. После выполнения этой команды в выводе будет указан текущий IP-адрес интерфейса eth0. Ответ "RTNETLINK answers: File exists" означает, что в сетевой конфигурации уже существует запись для указанного интерфейса с таким же IP-адресом, какой попытался назначить DHCP-сервер. Это может произойти, например, если был назначен статический IP-адрес на интерфейсе, и DHCP-сервер также попытался назначить ему другой IP-адрес. В таком случае, можно попробовать сначала удалить статическую конфигурацию интерфейса, а затем повторить попытку получения IP-адреса от DHCP-сервера.

## Part 7. **NAT**

* В файле */etc/apache2/ports.conf* на ws22 и r1 изменить строку `Listen 80` на `Listen 0.0.0.0:80`, то есть сделать сервер Apache2 общедоступным

<img src="src/screenshots/7.1.png" width="700">

* Запустить веб-сервер Apache командой `service apache2 start` на ws22 и r1

<img src="src/screenshots/7.2.png" width="700">

<img src="src/screenshots/7.3.png" width="700">

* Добавить в фаервол, созданный по аналогии с фаерволом из Части 4, на r2 следующие правила:
 1) удаление правил в таблице filter - `iptables -F`
 2) удаление правил в таблице "NAT" - `iptables -F -t nat`
 3) отбрасывать все маршрутизируемые пакеты - `iptables --policy FORWARD DROP`

 <img src="src/screenshots/7.4.png" width="700">

Запускаем фаервол.
 Проверить соединение между ws22 и r1 командой `ping`

 <img src="src/screenshots/7.5.png" width="700">

* Добавить в файл ещё одно правило:
 4) разрешить маршрутизацию всех пакетов протокола **ICMP**
 Проверить соединение между ws22 и r1 командой `ping`

<img src="src/screenshots/7.6.png" width="700">

<img src="src/screenshots/7.7.png" width="700">

* Добавить в файл ещё два правила:
 5) включить **SNAT**, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 
 6) включить **DNAT** на 8080 порт машины r2 и добавить к веб-серверу Apache, запущенному на ws22, доступ извне сети

<img src="src/screenshots/7.8.png" width="700">

* Включить в фаервол (межсетевой экран) разрешение для трафика TCP пакетов с адресом назначения на 80 порт (destination port) с помощью команды sudo iptables -A FORWARD -p tcp --dport 80 -j ACCEPT. Данное правило iptables в Linux Ubuntu Server 20.04 позволяет пропустить через межсетевой экран трафик TCP-пакетов с адресом назначения на порту 80 через межсетевой экран (firewall) Подробное описание параметров: -A FORWARD - добавление правила в цепочку FORWARD, отвечающую за пересылку пакетов между интерфейсами; -p tcp - указание протокола, в данном случае TCP; --dport 80 - указание порта назначения, в данном случае 80 (стандартный порт HTTP); Таким образом, данное правило позволяет пропустить TCP-трафик, направленный на порт 80, через межсетевой экран. Это может быть полезно, например, для разрешения доступа к веб-серверу, расположенному за межсетевым экраном, для пользователей внешней сети.

* Включить разрешение прохождения для трафика TCP пакетов через межсетевой экран с адресом источника на 80 порт (source port) с помощью команды sudo iptables -A FORWARD -p tcp --sport 80 -j ACCEPT. Отличие данного правила от предыдущего заключается в проверке порта источника (source port) в TCP-пакете: --sport 80: определяет порт источника (source port) в TCP-пакете. В данном случае, это порт 80, который обычно используется для HTTP-запросов. Предыдущее правило разрешает прохождение трафика на TCP-порту назначения (destination port), а данное правило разрешает прохождение трафика на TCP-порту источника (source port). Вместе они могут использоваться, например, для разрешения входящих и исходящих HTTP-запросов через межсетевой экран.

* Включить SNAT, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 (по обозначениям из Части 5 - сеть 10.20.0.0) с помощью правила настроек NAT для POSTROUTING цепочки в таблице NAT: sudo iptables -t nat -A POSTROUTING -o eth0 -s 10.20.0.0/26 -j SNAT --to-source 10.100.0.12. Описание параметров: -t nat: опция указывает таблицу nat, которая используется для настройки NAT. -A POSTROUTING: опция указывает, что правило должно быть добавлено в цепочку POSTROUTING таблицы nat. POSTROUTING цепочка применяет правила к пакетам, которые покидают сервер и отправляются во внешнюю сеть. -o eth0: опция указывает интерфейс, через который пакеты покидают сервер. В этом случае пакеты, которые покидают сервер, отправляются через интерфейс eth0. -s 10.20.0.0/26: опция указывает исходный IP-адрес для пакетов, которые будут обработаны правилом. В этом случае пакеты с IP-адресами в диапазоне 10.20.0.0 до 10.20.0.63 будут обработаны правилом. -j SNAT: опция указывает действие, которое будет выполнено, если пакет соответствует правилу. В этом случае действие SNAT используется для изменения исходного IP-адреса отправителя пакета. --to-source 10.100.0.12: опция указывает IP-адрес, на который нужно изменить исходный адрес отправителя пакета. В этом случае исходный адрес отправителя пакета будет изменён на 10.100.0.12. Таким образом, данное правило изменяет исходный IP-адрес пакетов, проходящих через выходной интерфейс enp0s8, и имеющих исходный IP-адрес в диапазоне 10.20.0.0/26, на 10.100.0.12. Отличие от предыдущего правила (sudo iptables -A FORWARD -p tcp --dport 80 -j ACCEPT) заключается в том, что это правило настраивает NAT для изменения исходного IP-адреса отправителя пакетов, а не просто разрешает прохождение пакетов с определенным портом.

* Включить DNAT на 8080 порт машины r2 и добавить к веб-серверу Apache, запущенному на ws22, доступ извне сети с помощью следующего правила настройки DNAT: iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 8080 -j DNAT --to-destination 10.20.0.20:80. Это правило iptables является правилом NAT (Network Address Translation) и определяет, что трафик, поступающий на сетевой интерфейс eth0 с портом назначения 8080 и протоколом TCP, должен быть перенаправлен на IP-адрес 10.20.0.20 с портом назначения 80 (по умолчанию для HTTP). Ключевое слово DNAT означает, что происходит изменение адреса назначения (Destination NAT). Описание параметров: -t nat: устанавливает таблицу NAT, которая используется для изменения сетевых адресов. -A PREROUTING: добавляет правило в цепочку PREROUTING таблицы NAT, которая обрабатывает входящий трафик до того, как он пройдет маршрутизацию. -i eth0: задает интерфейс входящего трафика. -p tcp: указывает протокол, которому принадлежит трафик. --dport 8080: указывает порт назначения трафика. -j DNAT: указывает, что нужно изменить адрес назначения пакета. --to-destination 10.20.0.20:80: указывает новый адрес и порт, на который нужно перенаправить трафик. Отличие от предыдущего правила заключается в том, что это правило применяется на входящий трафик (PREROUTING), тогда как предыдущее правило применяется на исходящий трафик (POSTROUTING). Также ключевое слово DNAT используется в этом правиле для изменения адреса назначения, в то время как в предыдущем правиле использовалось ключевое слово SNAT для изменения адреса источника.


* Проверить соединение по TCP для **SNAT**, для этого с ws22 подключиться к серверу Apache на r1 командой:
`telnet [адрес] [порт]`
* Проверить соединение по TCP для **DNAT**, для этого с r1 подключиться к серверу Apache на ws22 командой `telnet` (обращаться по адресу r2 и порту 8080)

 <img src="src/screenshots/7.9.png" width="700">
 <img src="src/screenshots/7.9.png" width="700">


